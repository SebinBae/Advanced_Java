-JVM 구조-

JVM은 Runtime Data Area과 Native 영역으로 나뉨

메소드 영역(Method Area) : 메소드 영역은 코드에서 사용되는 클래스들을 클래스 로더(Class Loader)로 읽어서
클래스별로 런타임 상수풀, 필드, 데이터, 메소드 데이터 코드 등을 분류해서 저장함. **메소드 영역은 JVM이 시작할 때 생성되고 모든 쓰레드가 공유하는 영역임**.

힙 영역(Heap) : 힙 영역은 객체가 생성되는 영역임. 힙 영역에서 생성된 객체는 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조함.
참조하는 변수나 필드가 없다면 의미없는 객체가 없기 때문에 쓰레기 수집기를 실행시켜서 쓰레기 객체를 힙 영역에서 자동으로 제거함.

JVM 스택(Stack) 영역 : JVM 스택 영역은 각 쓰레드마다 하나씩 존재하며 쓰레드가 시작될 때 할당됨.
JVM 스택은 메소드를 호출할 때마다 프레임을 추가(push)하고 메소드가 종료되면 해당 프레임을 제거(pop)하는 동작을 수행함.

PC 레지스터(Program Counter Register) : 현재 실행 중인 바이트 코드 명령어 주소를 저장함. 쓰레드마다 존재함.

네이티브 메소드 스택(Native Method Stack) : JNI 호출 시 C/C++ 같은 네이티브 코드 실행을 위한 스택임.


-GC-
GC는 힙 영역에서 더 이상 참조되지 않는 객체를 힙 영역에서 제거함.

선형 메모리 구조 : 한 덩어리의 메모리를 GC가 어떻게 관리하느냐를 이해하기 쉽도록 도식화한 거임.

Young Generation : 새로 생성된 객체들이 먼저 들어오는 공간임.
 - Eden → Survival 0 → Survival 1 순서로 Eden에서 살아남은 객체들이 이동하는 작은 공간임.
 - Young Generation이 꽉 차면 Minor GC가 발생하여 소수의 객체만 Old Generation으로 이동함.

Old Generation : Young Gen에서 여러 번 살아남은 장수 객체들이 모이는 곳임.
- Old Generation이 꽉 차면 Major GC(Full GC)가 발생함.

리전형 메모리 구조 : 힙을 리전 단위로 나눠서 관리하는 방식.
ex) 자바에서는 자바 9 이후로 G1 GC를 기본 GC로 사용함.

- Young/Old 영역을 물리적으로 고정하지 않고, 리전 단위로 동적으로 역할을 바꿈.